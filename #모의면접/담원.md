### 모의 면접 질문

<details> 
  <summary><b> 1. NullPointException에 대해 설명하시오.</b></summary>
   null에 .(Dot)을 찍게 되어서 참조할 곳이 없을 경우 NullPointerException 예외가 발생합니다.<br>
  개발자를 가장 많이 괴롭히는 예외 중 하나라고 볼 수 있습니다.
</details> 
<br>

<details> 
  <summary><b> 2. 오버라이딩과 오버로딩을 비교하시오</b></summary>
  <code>오버라이딩은 말 그대로, Overriding으로, 기존의 기능을 덮어 새로운 기능을 재정의 하는 것입니다. 각각의 인스턴스에 자신의 메소드가 호출되게 해주는 게 바로 메소드 오버라이딩 입니다.</code><br><br>
  반면 오버로딩은 같은 이름의 메소드를 매개변수의 타입이나 개수를 다르게 하여 여러 번 정의하는 것을 의미합니다. 이를 통해 같은 이름의 메소드가 다양한 입력에 대응할 수 있습니다.
 <body>
  <pre>
  class Shape {
        void draw() {
            System.out.println("Drawing Shape");
        }
        void draw(String color) {
            System.out.println("Drawing " + color + " Shape"); //오버로딩
        }
    }
    class Circle extends Shape {
        void draw() {
            System.out.println("Drawing Circle"); //오버 라이딩
        }
    }
  </pre>
  </body>

생성자을 여러개 생성할 때, 매개변수만 다르게 해서 오버로딩을 활용합니다.
</details> 
<br>

<details> 
  <summary><b> 3. 접근 제어자에서 차단에서 허용순서로 설명하세요</b></summary>
  private → default(package까지 좀 더 확장해서 봐주는 것) → proteted(package + 상속까지 봐주는 것) → public(전부 다 공개하는 것) 으로, 클래스 레벨, 필드, 생성자, 그리고 메서드에서 쓰입니다.<br> <br>

default(package-private)는 해당 접근 제어자를 사용하는 멤버는 동일한 패키지 내의 다른 클래스에서만 접근이 가능한 원본 상태라 볼 수 있습니다. <br>

private는 나의 클래스 안으로 속성과 기능을 숨길 때 사용하고, default는 나의 패키지 안으로 숨길 때, protected는 상속 관계로 속서과 기능을 숨길 때 사용한다고 볼 수 있습니다.<br>

<code>이를 통해서 자바에서 캡슐화를 구현합니다.</code>
</details> 
<br>

<details> 
  <summary><b> 4. 객체 지향 프로그래밍의 특징들에 대해 설명해주세요.</b></summary>
1. 캡슐화: 객체의 상태와 행위를 하나로 묶어 외부에서 접근을 제어하는 것 <br>
2. 추상화: 객체의 공통적인 특성을 추출하여 모델링하는 것 <br>
3. 상속: 부모 클래스의 특성을 자식 클래스가 물려받는 것 <br>
4. 다형성: 하나의 객체가 여러 가지 형태를 가질 수 있는 것 <br>
</details> 
<br>

<details> 
  <summary><b> 5. final에 대해 설명해주세요.</b></summary>
  final은 변수, 클래스, 메서에 붙일 수 있는 키워드입니다. final 변수는 값은 재할당이 불가능합니다.<br>
  final 메서드는 자식 클래스에서 오버라이드 할 수 없습니다. final 객체는 상속할 수 없습니다. (오류가 발생함)
</details> 
<br>

<details> 
  <summary><b> 6. 상속에 대해 설명해주세요.</b></summary>
  상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해 주는 것입니다. <br>
  이름 그대로 기존 클래스의 속성과 기능을 그대로 물려받는 것인데, 상속을 사용하려면 extends 키워드를 사용하면 됩니다. 단 , extends 대상은 하나만 선택할 수 있습니다.
</details> 
<br>

<details> 
  <summary><b> 7. 다형성을 사용하는 이유에 대해 설명하세요</b></summary>
  다형성과 오버라이딩을 사용해서 메서드와 배열을 활용으로 코드의 중복을 제거할 수 있기 때문입니다. <br>
  이로 레고 블럭 조립하듯이 컴포넌트를 쉽고 유연하게 변경하여 프로그램을 개발할 수 있습니다.
</details> 
<br>

<details> 
  <summary><b> 8. 추상 클래스에 대해 설명해주세요.</b></summary>
  부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스로, 상속 가능은 하나, 본인이 생성하지 못합니다.<br>
  추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언합니다.<br>
  또한 추상메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 하고, 이를 지키지 않을시 컴파일 오류가 발생합니다.
</details> 
<br>

<details> 
  <summary><b> 9. SOLID에 대해 설명해주세요.</b></summary>
<h3> SRP (Single Responsibility Principle) 단일 책임 원칙</h3>

- 하나의 클래스는 하나의 책임만 가져야 한다.
- **클래스를 변경하는 이유는 단 하나여야 한다.**

<h3> OCP (Open-Closed Principle) 개방-폐쇄 원칙</h3>

- **소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**
- 즉, 기존의 코드를 변경하지 않고 기능을 수정, 추가할 수 있도록 설계해야한다.

<h3> LSP (Liskov Substitution Principle) 리스코프 치환 원칙</h3>

- 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 한다.
    - **즉, 상위 타입 객체를 하위 타입 객체로 대체하여도 정상적으로 동작해야 한다.**
- 추가질문 LSP를 위반하면 OCP도 위반하는 것일까? (o)

<h3> ISP (Interface Segregation Principle) 인터페이스 분리 원칙</h3>

- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다.
- **특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 한 개보다 낫다**
- **인터페이스에 변경이 발생해도 다른 인터페이스는 영향을 받지 않도록 만드는 것이 ISP의 핵심**

<h3> DIP (Dependency Inversion Principle) 의존 역전 원칙</h3>

프로그래머는 **"추상회에 의존해야지, 구체화에 의존하면 안된다."** 의존성 주입은 이 말을 따르는 방법 중 하나다.

- 의존 관계를 맺을 때, 변하기 쉬운 구체적인 것 보다는 변하기 어려운 추상적인 것에 의존해야 한다는 것이다.
    - **즉, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.**
</details> 
<br>

<details> 
  <summary><b> 10.  GC의 역할에 대해 설명하세요 </b></summary>
  아무도 참조하지 않는 인스턴스를 메모리에서 제거하기 위해 자바에서 처리하는 역할을 담당합니다. 그리고 지우는 과정에서 모아서 한 번에 없애는 역할을 합니다.<br>
객체는 해당 객체를 참조하는 곳이 있으면, JVM이 종료할 때 까지 계속 생존합니다.<br>
그런데 중간에 해당 객체를 참조하는 곳이 모두 사라지면 JVM은 그때 필요 없는 객체로 판단하고 GC(가비지 컬렉션)를 사용해서 제거합니다.<br>

<code>추가 질문 : GC의 단점은?</code>
 <pre> - 가비지 컬렉션이 실행될 때는 반드시 애플리케이션을 중지시키는 Stop The World(SWT)가 수행되는데, 
   이는 GC를 실행하기위한 Thread를 제외하고 이외의 모든 Trhead를 멈추게 합니다. 이로 인해 오버헤드가 일어나는데, 
   오버헤드는 성능 저하의 원인이 될 수 있습니다. 
   그리고 프로그램이 예측 불가능하게 일시 정지 될 수 있기 때문에 실시간 시스템에 적합하지 않습니다.</pre>

+ 추가 질문 : GC의 장점은?
  <pre>GC의 가장 큰 장점은 개발자가 동적으로 할당된 메모리 전체를 관리할 필요가 없어집니다.
    이로 인해 유효하지 않은 포인터에 접근하거나 이미 한번 해제한 메모리를 두 번 해제하는 등 버그나 불필요한 작업을 해소할 수 있습니다.</pre>

</details> 
<br>
